/* automatically generated by rust-bindgen 0.65.1 */

#[doc = " Signed 32 bit integer."]
pub const ExtismValType_I32: ExtismValType = 0;
#[doc = " Signed 64 bit integer."]
pub const ExtismValType_I64: ExtismValType = 1;
#[doc = " Floating point 32 bit integer."]
pub const ExtismValType_F32: ExtismValType = 2;
#[doc = " Floating point 64 bit integer."]
pub const ExtismValType_F64: ExtismValType = 3;
#[doc = " A 128 bit number."]
pub const ExtismValType_V128: ExtismValType = 4;
#[doc = " A reference to a Wasm function."]
pub const ExtismValType_FuncRef: ExtismValType = 5;
#[doc = " A reference to opaque data in the Wasm instance."]
pub const ExtismValType_ExternRef: ExtismValType = 6;
#[doc = " A list of all possible value types in WebAssembly."]
pub type ExtismValType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtismContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtismCancelHandle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtismFunction {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtismCurrentPlugin {
    _unused: [u8; 0],
}
pub type ExtismSize = u64;
#[doc = " A union type for host function argument/return values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExtismValUnion {
    pub i32_: i32,
    pub i64_: i64,
    pub f32_: f32,
    pub f64_: f64,
}
#[test]
fn bindgen_test_layout_ExtismValUnion() {
    const UNINIT: ::std::mem::MaybeUninit<ExtismValUnion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExtismValUnion>(),
        8usize,
        concat!("Size of: ", stringify!(ExtismValUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<ExtismValUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(ExtismValUnion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismValUnion),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismValUnion),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismValUnion),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismValUnion),
            "::",
            stringify!(f64_)
        )
    );
}
#[doc = " `ExtismVal` holds the type and value of a function argument/return"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExtismVal {
    pub t: ExtismValType,
    pub v: ExtismValUnion,
}
#[test]
fn bindgen_test_layout_ExtismVal() {
    const UNINIT: ::std::mem::MaybeUninit<ExtismVal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExtismVal>(),
        16usize,
        concat!("Size of: ", stringify!(ExtismVal))
    );
    assert_eq!(
        ::std::mem::align_of::<ExtismVal>(),
        8usize,
        concat!("Alignment of ", stringify!(ExtismVal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismVal),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExtismVal),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " Host function signature"]
pub type ExtismFunctionType = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut ExtismCurrentPlugin,
        inputs: *const ExtismVal,
        n_inputs: ExtismSize,
        outputs: *mut ExtismVal,
        n_outputs: ExtismSize,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ExtismPlugin = i32;
extern "C" {
    #[doc = " Create a new context"]
    pub fn extism_context_new() -> *mut ExtismContext;
}
extern "C" {
    #[doc = " Free a context"]
    pub fn extism_context_free(ctx: *mut ExtismContext);
}
extern "C" {
    #[doc = " Returns a pointer to the memory of the currently running plugin\n NOTE: this should only be called from host functions."]
    pub fn extism_current_plugin_memory(plugin: *mut ExtismCurrentPlugin) -> *mut u8;
}
extern "C" {
    #[doc = " Allocate a memory block in the currently running plugin\n NOTE: this should only be called from host functions."]
    pub fn extism_current_plugin_memory_alloc(
        plugin: *mut ExtismCurrentPlugin,
        n: ExtismSize,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the length of an allocated block\n NOTE: this should only be called from host functions."]
    pub fn extism_current_plugin_memory_length(
        plugin: *mut ExtismCurrentPlugin,
        n: ExtismSize,
    ) -> ExtismSize;
}
extern "C" {
    #[doc = " Free an allocated memory block\n NOTE: this should only be called from host functions."]
    pub fn extism_current_plugin_memory_free(plugin: *mut ExtismCurrentPlugin, ptr: u64);
}
extern "C" {
    #[doc = " Create a new host function\n\n Arguments\n - `name`: function name, this should be valid UTF-8\n - `inputs`: argument types\n - `n_inputs`: number of argument types\n - `outputs`: return types\n - `n_outputs`: number of return types\n - `func`: the function to call\n - `user_data`: a pointer that will be passed to the function when it's called\n    this value should live as long as the function exists\n - `free_user_data`: a callback to release the `user_data` value when the resulting\n   `ExtismFunction` is freed.\n\n Returns a new `ExtismFunction` or `null` if the `name` argument is invalid."]
    pub fn extism_function_new(
        name: *const ::std::os::raw::c_char,
        inputs: *const ExtismValType,
        n_inputs: ExtismSize,
        outputs: *const ExtismValType,
        n_outputs: ExtismSize,
        func: ExtismFunctionType,
        user_data: *mut ::std::os::raw::c_void,
        free_user_data: ::std::option::Option<
            unsafe extern "C" fn(__: *mut ::std::os::raw::c_void),
        >,
    ) -> *mut ExtismFunction;
}
extern "C" {
    #[doc = " Set the namespace of an `ExtismFunction`"]
    pub fn extism_function_set_namespace(
        ptr: *mut ExtismFunction,
        namespace_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Free an `ExtismFunction`"]
    pub fn extism_function_free(ptr: *mut ExtismFunction);
}
extern "C" {
    #[doc = " Create a new plugin with additional host functions\n\n `wasm`: is a WASM module (wat or wasm) or a JSON encoded manifest\n `wasm_size`: the length of the `wasm` parameter\n `functions`: an array of `ExtismFunction*`\n `n_functions`: the number of functions provided\n `with_wasi`: enables/disables WASI"]
    pub fn extism_plugin_new(
        ctx: *mut ExtismContext,
        wasm: *const u8,
        wasm_size: ExtismSize,
        functions: *mut *const ExtismFunction,
        n_functions: ExtismSize,
        with_wasi: bool,
    ) -> ExtismPlugin;
}
extern "C" {
    #[doc = " Update a plugin, keeping the existing ID\n\n Similar to `extism_plugin_new` but takes an `index` argument to specify\n which plugin to update\n\n Memory for this plugin will be reset upon update"]
    pub fn extism_plugin_update(
        ctx: *mut ExtismContext,
        index: ExtismPlugin,
        wasm: *const u8,
        wasm_size: ExtismSize,
        functions: *mut *const ExtismFunction,
        nfunctions: ExtismSize,
        with_wasi: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove a plugin from the registry and free associated memory"]
    pub fn extism_plugin_free(ctx: *mut ExtismContext, plugin: ExtismPlugin);
}
extern "C" {
    #[doc = " Get plugin ID for cancellation"]
    pub fn extism_plugin_cancel_handle(
        ctx: *mut ExtismContext,
        plugin: ExtismPlugin,
    ) -> *const ExtismCancelHandle;
}
extern "C" {
    #[doc = " Cancel a running plugin"]
    pub fn extism_plugin_cancel(handle: *const ExtismCancelHandle) -> bool;
}
extern "C" {
    #[doc = " Remove all plugins from the registry"]
    pub fn extism_context_reset(ctx: *mut ExtismContext);
}
extern "C" {
    #[doc = " Update plugin config values, this will merge with the existing values"]
    pub fn extism_plugin_config(
        ctx: *mut ExtismContext,
        plugin: ExtismPlugin,
        json: *const u8,
        json_size: ExtismSize,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if `func_name` exists"]
    pub fn extism_plugin_function_exists(
        ctx: *mut ExtismContext,
        plugin: ExtismPlugin,
        func_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Call a function\n\n `func_name`: is the function to call\n `data`: is the input data\n `data_len`: is the length of `data`"]
    pub fn extism_plugin_call(
        ctx: *mut ExtismContext,
        plugin_id: ExtismPlugin,
        func_name: *const ::std::os::raw::c_char,
        data: *const u8,
        data_len: ExtismSize,
    ) -> i32;
}
extern "C" {
    #[doc = " Get the error associated with a `Context` or `Plugin`, if `plugin` is `-1` then the context\n error will be returned"]
    pub fn extism_error(
        ctx: *mut ExtismContext,
        plugin: ExtismPlugin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the length of a plugin's output data"]
    pub fn extism_plugin_output_length(ctx: *mut ExtismContext, plugin: ExtismPlugin)
        -> ExtismSize;
}
extern "C" {
    #[doc = " Get a pointer to the output data"]
    pub fn extism_plugin_output_data(ctx: *mut ExtismContext, plugin: ExtismPlugin) -> *const u8;
}
extern "C" {
    #[doc = " Set log file and level"]
    pub fn extism_log_file(
        filename: *const ::std::os::raw::c_char,
        log_level: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the Extism version string"]
    pub fn extism_version() -> *const ::std::os::raw::c_char;
}
